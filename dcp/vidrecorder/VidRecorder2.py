import os
import sys
import time
import datetime
import logging
import threading
import traceback
import configparser
import shutil

from global_vars import g
from DeviceRecorder import DeviceRecorder
from DriveManager import DriveManager
from utils.dirmonitor import DirMonitor
import utils.vidlogging as vidlogging
from utils import utils
from utils import fileutils

logger = vidlogging.get_logger(__name__,filename=g.paths['logfile'])

class VidDirMonitor(DirMonitor):
    def __init__(self, dirpath, hz=2, logger=print, update_callback=None):
        super().__init__(dirpath,hz,logger,update_callback)
        
        # self.dirpath points to the session directory for this recording session formatted <num>_<timestamp>
        self.basedir = os.path.basename(self.dirpath)
        self.hdd = g.paths['hdd'] # list of hard drives on the system
        self.vid_ext = '.mp4'

    def calc_chapter_stats(self,t,wsid,chapters):
        '''Compute filestats for all chapters for this wsid

           it is assumed "chapters" contains only chapters for this wsid
        '''
        filestats = DriveManager.calc_chapter_stats(wsid,chapters)
        filestats['time'] = t
        return filestats

    def collect_file_stats2(self,t):
        '''Returns list of filestats generated by calc_chapter_stats for all chapters in the current session'''

        logger.debug('-----------------------------------------------------------------------------------------------')
        logger.debug(f'VidDirMonitor::collect_file_stats -- {threading.current_thread().name} -- Drives: {self.hdd} -- Session Dir: {self.basedir}')
        allstats = []
        filelist = []

        # Get list of files in current session directory, note these can span multiple hard drives
        for drive in self.hdd:
            hdd_dirpath = os.path.join(drive,self.basedir)
            if os.path.isdir(hdd_dirpath): # session dir might not span over multiple drives yet so ignore the drive if dne
                hdd_filelist = os.listdir(hdd_dirpath)
                for i,f in enumerate(hdd_filelist):
                    absf = os.path.join(hdd_dirpath,f)
                    if os.path.isfile(absf) and len(absf) > len(self.vid_ext) and absf[-4:] == self.vid_ext: # make sure we skip any non .mp4 files and dirs
                        filelist.append((f,absf))

        # filelist now contains abs path of all of the chapter files associated with the current recording session, lets sort them by workstation
        filelist.sort()
        absflist = [tup[1] for tup in filelist]

        if not absflist:
            return []

        # iterate over filelist breaking them into chapter slices by workstation as you move along
        si = 0
        cur_wsid = None
        for i,f in enumerate(absflist):
            last_file = (i == len(absflist)-1)
            wsid, _ , _ = DriveManager.parse_chapter_file_name(f)
            if i == 0:
                cur_wsid = wsid
            if cur_wsid != wsid:
                filelist_slice = absflist[si:i]
                filestats = self.calc_chapter_stats(t,cur_wsid,filelist_slice)
                allstats.append(filestats)
                si = i
                cur_wsid = wsid
                # print(f'i: {i} -- wsid: {wsid} -- filelist_slice: {filelist_slice}')
            if last_file:
                filelist_slice = absflist[si:]
                filestats = self.calc_chapter_stats(t,cur_wsid,filelist_slice)
                allstats.append(filestats)
                # print(f'i: {i} -- wsid: {wsid} -- filelist_slice: {filelist_slice}')

        for i,stats in enumerate(allstats):
            logger.debug(f'allstats[{i}]: {stats["wsid"]}:, time: {stats["time"]}, size: {stats["size"]}, file: {stats["basename"]}')
                #   f'             fullname: {stats["fullname"]}\n' \
                #   f'             min_chapter_id: {stats["min_chapter_id"]}, max_chapter_id: {stats["max_chapter_id"]}: chapter_count: {stats["chapter_count"]}')
        return allstats
    
    def collect_file_stats(self,t):
        allstats = []
        try:
            allstats = self.collect_file_stats2(t)
        except:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            output = "\n"
            for s in traceback.format_exception(exc_type,exc_value,exc_traceback):
                output += s
            logger.error(output)
        return allstats

class VidRecorder2():

  def __init__(self, wslist, hdd, sdpdir, update_callback=None, duration=None, video_monitor_on=True, use_dev_dir=True):

    self.device_list = [] # each workstation is represented by one device
    self.wslist = wslist # list of dicts representing all SELECTED workstations, look get_selected_workstations for format

    self.cur_drive = None
    self.sessionDirectory = None # this is the current timestamped directory where recorded data is being stored
    self.update_gui_callback = update_callback
    self.is_recording = False
    self.video_monitor = None
    self.video_monitor_on = video_monitor_on

    # These might get deprecated with auto run and new storage system
    self.duration = duration
    self.duration_thread = None
    self.sdpdir = sdpdir
    self.use_dev_dir  = use_dev_dir

    (self.wslist, self.cur_drive, self.sessionDirectory) = self.create_directory_structure(hdd,self.wslist,self.use_dev_dir)
    g.paths['sessiondir'] = os.path.basename(self.sessionDirectory)
    DeviceRecorder.best_drive = self.cur_drive

  def start(self):
      ''' Create all devices and start recording'''

      # if we are already recording just return
      logger.info('VidRecorder start()!!!!')
      if (self.is_recording):
          return

      # Create all devices and download sdp for each
      self.device_list = []
      workstation_info = [] # list of dicts representing each workstation that will be sent to gui for updates

      # Create the sdp directory inside of the current sessionDirectory.
      # All of the sdp files for this session will be stored here.
      session_sdp_dir = os.path.join(self.sessionDirectory,'sdp')
      fileutils.dcp_mkdir(session_sdp_dir,g.log['group'],g.log['permissions'])
    #   if not os.path.isdir(session_sdp_dir):
    #       os.mkdir(session_sdp_dir)

      n = len(self.wslist) # number of selected workstations
      sdp_download_failed = [False for i in range(n)]
      chunk_duration_min = g.advanced['video_chunking_duration_in_minutes'] if g.advanced['video_chunking_enabled'] else 0
      for i in range(n):
          d = DeviceRecorder(self.wslist[i],sdpdir=session_sdp_dir,chunk_duration_min=chunk_duration_min)
          w = d.get_workstation_info()
          try:
              success, orig_sdp, vid_sdp, aud_sdp = d.download_sdp()
              self.device_list.append(d) # note if the sdp download fails then the device will
                                         # never be added to list...that is the behavior we want
          except:
              logger.error('SDP download failed')
              success = False
              sdp_download_failed[i] = True
          w['sdp_downloaded'] = success
          workstation_info.append(w)

     
      # Wait for all sdp's to be downloaded
      logger.info('WAITING FOR SDPs to download.............')
      all_sdp_downloaded = False
      while not all_sdp_downloaded:
          all_sdp_downloaded = True
          for d in self.device_list:
                if not sdp_download_failed[i] and not d.sdp_downloaded:
                      all_sdp_downloaded = False
                      logger.debug(f'Device {d.id} has not finished downloading sdp yet')
                      break
      logger.info('ALL SDPs downloaded!!!!!!!!!!!!!!!')

      # Update gui with SDP download status of all devices
      print('Updating gui with SDP download status')
      self.update_gui_callback({
          'type': 'SDP Download Status',
          'workstation_info': workstation_info,
      })

      # Dump devices for debugging purposes
      print('------------------------')
      for d in self.device_list:
            print(d)
      print('------------------------')

      # Start all the devices recording
      for d in self.device_list:
          if not d.sdp_downloaded:
              continue
          success = d.start_recording(duration=self.duration,monitor=True)
          if not success:
              logger.error(f"Error: Recording device {d.id} at {d.ip} FAILED to start")
          else:
              logger.info(f"Recording device {d.id} at {d.ip} has started")
      self.is_recording = True
      
      # Let gui know recording has begun for all devices
      self.update_gui_callback({
          'type': 'Recording started',
          'duration': self.duration,
      })

      # if enabled, turn on the dir monitor so we can see if the vlc processes are operating as they should
      if self.video_monitor_on:
          if not self.video_monitor:
              self.video_monitor = VidDirMonitor(
                  dirpath=f'{self.sessionDirectory}',
                  hz=1.0,
                  logger=logger.info,
                  update_callback=self.dir_monitor_update_callback)
          if not self.video_monitor.running:
              self.video_monitor.start() # this runs in its own thread
              
    #   self.drive_space_check_thread = threading.Timer(interval=1, function=self.drive_space_check)
    #   self.drive_space_check_thread.daemon = True
    #   self.drive_space_check_thread.start()

  def stop(self):
    '''Stops recording of all devices in self.device_list and updates gui'''
    logger.info('VidRecorder Stop!!!!!')
    for d in self.device_list:
      d.stop_recording()
      d.quick_info()

    self.is_recording = False
    self.update_gui_callback({
      'type': 'Recording stopped',
      'workstation_info': self.get_workstation_info(),
      'duration': self.duration,
      'abort': False,
      })

    # Shut down the video monitoring on stop
    if self.video_monitor and self.video_monitor.running:
      self.video_monitor.stop()
      self.video_monitor = None
      
    # Stop the drive check timer
    # if self.drive_space_check_thread:
    #     self.drive_space_check_thread.cancel()

  def get_workstation_info(self):
      w_info_list = []
      for d in self.device_list:
          w_info = d.get_workstation_info()
          w_info_list.append(w_info)
      return w_info_list

  def dir_monitor_update_callback(self,filestats):
      '''VidDirMonitor class will call this function after every directory check and pass the filestats'''

      logger.debug('-----------------------------------------------------------------------------------------------')
      logger.debug(f'VidRecorder2::dir_monitor_update_callback -- {threading.current_thread().name} -- called from VidDirMonitor')
      
      if not filestats:
          print('filestats is empty in dir_monitor_update_callback')
          return
      
      workstation_info = self.get_workstation_info()

      for i,d in enumerate(self.device_list):
          for stats in filestats:

              basename = stats['basename']

              # Do stuff based on file stats if you want to
              #
              # IMPORTANT NOTE: This function is being executed by the DirMonitor. Be careful with this
              # If you are running in another process you can't make any state changes, they don't share the same
              # memory space
              #
              if basename == d.vid_basename:
                  d.handle_file_check(stats)
                  workstation_info[i]['filestats'] = stats
                  break

      if (not self.duration_thread and self.duration and self.duration > 0):
          for w in workstation_info:
              # Start duration timer here (in minutes)
              print(f'{w["id"]}: is_recording: {w["is_recording"]}')
              if w['is_recording']:
                  self.duration_thread = threading.Timer(interval=self.duration*60, function=self.stop)
                  self.duration_thread.start()
                  break

      video_storage = DriveManager.get_video_storage_stats(DeviceRecorder.best_drive)
      DriveManager.print_drive_stats(video_storage)

      self.update_gui_callback({
          'type': 'Update',
          'workstation_info': workstation_info,
          'diskstats': shutil.disk_usage('/'),
          'video_storage': video_storage,
          })

  def create_directory_structure(self,hdd,workstations,use_dev_dir=False):
        '''Creates timestamped directory to store vid files in
           Also updates the wslist such that each workstation in the list has it's
           corresponding w['dir'] value set to the absolute location where it will
           be stored.
        '''
        best_drive, max_session_id = DriveManager.pick_best_drive(self.cur_drive,len(workstations))
        
        timestamp = f'{datetime.date.today().strftime("%Y-%b-%d")}_{time.strftime("%Hh%Mm%Ss", time.localtime())}'
        session_dir_fullpath = f'{best_drive}/{(max_session_id+1):02}_{timestamp}'
        fileutils.dcp_mkdir(session_dir_fullpath,g.log['group'],g.log['permissions'])
        # os.mkdir(session_dir_fullpath)
        for w in workstations:
            if (use_dev_dir):
                w['dir'] = session_dir_fullpath
            else:
                wid = f'{workstations.index(w) + 1:02}'
                w['dir'] = f'{session_dir_fullpath}/WS{wid}'
            if not os.path.isdir(w['dir']):
                fileutils.dcp_mkdir(w['dir'],g.log['group'],g.log['permissions'])
                # os.mkdir(w['dir'])

        return (workstations,best_drive,session_dir_fullpath)
    
#   def drive_space_check(self):
#       best_drive, max_session_id = DriveManager.pick_best_drive(self.cur_drive,len(self.device_list))
#     #   print(f'self.cur_drive: {self.cur_drive} -- BEFORE')
#     #   print(f'viddir: {g.paths["viddir"]} -- BEFORE')
#       if best_drive != self.cur_drive:
#           self.cur_drive = best_drive
#           g.paths['viddir'] = best_drive
#     #   print(f'self.cur_drive: {self.cur_drive} -- AFTER')
#     #   print(f'viddir: {g.paths["viddir"]} -- AFTER')
#     #   print(f'best_drive: {best_drive} -- max_session_id: {max_session_id}')
#       if (self.is_recording):
#           self.drive_space_check_thread = threading.Timer(interval=1, function=self.drive_space_check)
#           self.drive_space_check_thread.daemon = True
#           self.drive_space_check_thread.start()
#       else:
#           if self.drive_space_check_thread:
#               self.drive_space_check_thread.cancel()
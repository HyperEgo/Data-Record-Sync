import os
import sys
import time
import datetime
import logging
import threading
import traceback
import configparser
import shutil


from global_vars import g
from DeviceRecorder import DeviceRecorder
from DriveManager import DriveManager
from utils.dirmonitor import DirMonitor
import utils.vidlogging as vidlogging
from utils import utils
import utils.fileutils as fileutils
from components.session import Session
from components.session import get_all_sessions

logger = vidlogging.get_logger(__name__,filename=g.paths['logfile'])

class VidDirMonitor(DirMonitor):
    def __init__(self, dirpath, hz=2, logger=print, update_callback=None):
        super().__init__(dirpath,hz,logger,update_callback)

        # self.dirpath points to the session directory for this recording session formatted <num>_<timestamp>
        self.basedir = os.path.basename(self.dirpath)
        self.hdd = g.paths['hdd'] # list of hard drives on the system
        self.vid_ext = '.mp4'

    def calc_chapter_stats(self,t,wsid,chapters):
        '''Compute filestats for all chapters for this wsid

           it is assumed "chapters" contains only chapters for this wsid
        '''
        filestats = DriveManager.calc_chapter_stats(wsid,chapters)
        filestats['time'] = t
        return filestats

    def collect_file_stats2(self,t):
        '''Returns list of filestats generated by calc_chapter_stats for all chapters in the current session'''

        logger.debug('-----------------------------------------------------------------------------------------------')
        logger.debug(f'VidDirMonitor::collect_file_stats -- {threading.current_thread().name} -- Drives: {self.hdd} -- Session Dir: {self.basedir}')
        allstats = []
        filelist = []

        # Get list of files in current session directory, note these can span multiple hard drives
        for drive in self.hdd:
            hdd_dirpath = os.path.join(drive,self.basedir)
            if os.path.isdir(hdd_dirpath): # session dir might not span over multiple drives yet so ignore the drive if dne
                hdd_filelist = os.listdir(hdd_dirpath)
                for i,f in enumerate(hdd_filelist):
                    absf = os.path.join(hdd_dirpath,f)
                    if os.path.isfile(absf) and len(absf) > len(self.vid_ext) and absf[-4:] == self.vid_ext: # make sure we skip any non .mp4 files and dirs
                        filelist.append((f,absf))

        # filelist now contains abs path of all of the chapter files associated with the current recording session, lets sort them by workstation
        filelist.sort()
        absflist = [tup[1] for tup in filelist]

        if not absflist:
            return []

        # iterate over filelist breaking them into chapter slices by workstation as you move along
        si = 0
        cur_wsid = None
        for i,f in enumerate(absflist):
            last_file = (i == len(absflist)-1)
            wsid, _ , _ = DriveManager.parse_chapter_file_name(f)
            if i == 0:
                cur_wsid = wsid
            if cur_wsid != wsid:
                filelist_slice = absflist[si:i]
                filestats = self.calc_chapter_stats(t,cur_wsid,filelist_slice)
                allstats.append(filestats)
                si = i
                cur_wsid = wsid
                # print(f'i: {i} -- wsid: {wsid} -- filelist_slice: {filelist_slice}')
            if last_file:
                filelist_slice = absflist[si:]
                filestats = self.calc_chapter_stats(t,cur_wsid,filelist_slice)
                allstats.append(filestats)
                # print(f'i: {i} -- wsid: {wsid} -- filelist_slice: {filelist_slice}')

        for i,stats in enumerate(allstats):
            stats_display = f'allstats[{i}]: {stats["wsid"]}:, time: {stats["time"]}, size: {stats["size"]}\n'
            for fs in stats["filestats"]:
                if fs:
                    stats_display += f'file: {fs["basename"]}'
            logger.debug(stats_display)
                #   f'             fullname: {stats["fullname"]}\n' \
                #   f'             min_chapter_id: {stats["min_chapter_id"]}, max_chapter_id: {stats["max_chapter_id"]}: chapter_count: {stats["chapter_count"]}')
        return allstats

    def collect_file_stats(self,t):
        allstats = []
        try:
            allstats = self.collect_file_stats2(t)
        except:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            output = "\n"
            for s in traceback.format_exception(exc_type,exc_value,exc_traceback):
                output += s
            logger.error(output)
        return allstats

class VidRecorder():

  def __init__(self, wslist, hdd, update_callback=None, duration=None, video_monitor_on=True, use_dev_dir=True):

    logger.debug("VidRecorder.__init__()")
    self.device_list = [] # each workstation is represented by one device

    # From constructor inputs
    self.wslist = wslist # list of dicts representing all SELECTED workstations, look get_selected_workstations for format
    self.update_gui_callback = update_callback # use this function to update gui
    self.video_monitor_on = video_monitor_on # is this even needed? I mean, I think this has
                                             # to be on or the whole system doesn't operate

    self.is_recording = False # can be queried to see if we are currently recording
    self.video_monitor = None # instance of VidDirMonitor

    self.cur_drive = None # drive we are currently recording on
    self.sessionDirectory = None # current timestamped directory where recorded data is being stored
                                 # every record start/stop creates a new one of these
    self.use_dev_dir  = use_dev_dir # deprecate this with auto run and new storage system ???

    # Choose best drive to record on and create the new time-stamped session directory
    (self.wslist, self.cur_drive, self.sessionDirectory) = \
        self.create_directory_structure(hdd,self.wslist,self.use_dev_dir)

    # logger.debug("")

    g.paths['sessiondir'] = os.path.basename(self.sessionDirectory)
    DeviceRecorder.best_drive = self.cur_drive

    logger.debug(f'__init__ -> \n{self}')

  def start(self):
      ''' Create all devices and start recording'''

      # if we are already recording just return
      logger.info('VidRecorder start()!!!!')
      if (self.is_recording):
          return

      # Create all devices and download sdp for each
      self.device_list = []
      device_info_list = [] # list of dicts representing each workstation that will be sent to gui for updates

      # Create the sdp directory inside of the current sessionDirectory.
      # All of the sdp files for this session will be stored here.
      session_sdp_dir = os.path.join(self.sessionDirectory,'sdp')
      if not os.path.isdir(session_sdp_dir):
          fileutils.dcp_mkdir(session_sdp_dir,g.log['group'],g.log['permissions'])

      n = len(self.wslist) # number of selected workstations
      sdp_download_failed = [False for i in range(n)]
      chapter_duration_min = g.advanced['video_chapters_duration_in_minutes'] if g.advanced['video_chapters_enabled'] else 0
      DeviceRecorder.ws_count = 0
      for i in range(n):
          device = DeviceRecorder(self.wslist[i],sdpdir=session_sdp_dir,chapter_duration_min=chapter_duration_min)
          device_info = device.get_info()
          try:
              success, orig_sdp, vid_sdp, aud_sdp = device.download_sdp()
              self.device_list.append(device) # note if the sdp download fails then the device will
                                              # never be added to list...that is the behavior we want
          except:
              logger.error('SDP download failed')
              success = False
              sdp_download_failed[i] = True
          device_info['sdp_downloaded'] = success
          device_info_list.append(device_info)

      # Wait for all sdp's to be downloaded
      logger.info('WAITING FOR SDPs to download.............')
      all_sdp_downloaded = False
      while not all_sdp_downloaded:
          all_sdp_downloaded = True
          for device in self.device_list:
                if not sdp_download_failed[i] and not device.sdp_downloaded:
                      all_sdp_downloaded = False
                      logger.debug(f'Device {device.id} has not finished downloading sdp yet')
                      break
      logger.info('ALL SDPs downloaded!!!!!!!!!!!!!!!')

      # Update gui with SDP download status of all devices
      logger.debug('Updating gui with SDP download status')
      self.update_gui_callback({
          'type': 'SDP Download Status',
          'workstation_info': device_info_list,
      })

      # Dump devices for debugging purposes
      logger.info('------------------------')
      logger.info('After sdp download these are the devices still in the list')
      for d in self.device_list:
            logger.info(d)
      logger.info('------------------------')

      # Start all the devices recording
      for d in self.device_list:
          if not d.sdp_downloaded:
              continue
          success = d.start_recording(monitor=True)
          if not success:
              logger.error(f"Error: Recording device {d.id} at {d.ip} FAILED to start")
          else:
              logger.info(f"Recording device {d.id} at {d.ip} has started")
      self.is_recording = True

      # Let gui know recording has begun for all devices
      self.update_gui_callback({
          'type': 'Recording started',
      })

      # if enabled, turn on the dir monitor so we can see if the vlc processes are operating as they should
      if self.video_monitor_on:
          if not self.video_monitor:
              self.video_monitor = VidDirMonitor(
                  dirpath=f'{self.sessionDirectory}',
                  hz=1.0,
                  logger=logger.info,
                  update_callback=self.dir_monitor_update_callback)
          if not self.video_monitor.running:
              self.video_monitor.start() # this runs in its own thread

    #   self.drive_space_check_thread = threading.Timer(interval=1, function=self.drive_space_check)
    #   self.drive_space_check_thread.daemon = True
    #   self.drive_space_check_thread.start()

  def stop(self):
    '''Stops recording of all devices in self.device_list and updates gui'''
    logger.info('VidRecorder Stop!!!!!')
    for d in self.device_list:
      d.stop_recording()
      d.quick_info()

    self.is_recording = False
    self.update_gui_callback({
      'type': 'Recording stopped',
      'workstation_info': self.get_workstation_info(),
      'abort': False,
      })

    # Shut down the video monitoring on stop
    if self.video_monitor and self.video_monitor.running:
      self.video_monitor.stop()
      self.video_monitor = None

    # Stop the drive check timer
    # if self.drive_space_check_thread:
    #     self.drive_space_check_thread.cancel()

  def find_device(self,wsid: int):
      for i,device in enumerate(self.device_list):
          if wsid == device.id:
              return (device, i)

  def get_workstation_info(self):
      w_info_list = []
      for d in self.device_list:
          w_info = d.get_info()
          w_info_list.append(w_info)
      return w_info_list

  def dir_monitor_update_callback(self,chapter_stats):
      '''VidDirMonitor class will call this function after every directory check and pass the filestats
         chapter_stats: is built and returned from DriveManager.calc_chapter_stats
      '''

      logger.debug('-----------------------------------------------------------------------------------------------')
      logger.debug(f'VidRecorder::dir_monitor_update_callback -- {threading.current_thread().name} -- called from VidDirMonitor')

      if not chapter_stats:
          logger.debug('chapter_stats is empty in VidRecorder.dir_monitor_update_callback')
          return

    #   workstation_info = self.get_workstation_info() # returns list of device.get_info()

      for stats in chapter_stats:
          (device, _) = self.find_device(stats['wsid_int'])
          if not device:
              logger.debug('ERROR: Reported chapter_stats for workstation that doesn''t exist')
              logger.debug(stats)
              continue
          else:
              logger.debug("MATCH!!!!!!!!!!!!!!!!!!!!")
              device.record_update(stats) # update our DeviceRecorder and associated RecordingProcesses

    #   for i,device in enumerate(self.device_list):
    #       for stats in chapter_stats:
    #           chapter_wsid_int = stats['wsid_int']

    #           # Do stuff based on file stats if you want to
    #           #
    #           # IMPORTANT NOTE: This function is being executed by the DirMonitor. Be careful with this
    #           # If you are running in another process you can't make any state changes, they don't share the same
    #           # memory space
    #           #
    #           if chapter_wsid_int == device.id:
    #               logger.debug("MATCH!!!!!!!!!!!!!!!!!!!!")
    #               device.record_update(stats)
    #             #   workstation_info[i]['update_stats'] = stats
    #               break

      # Info bundle #2 -- Device stats + RecordingProcess stats + Collected Chapter stats
      workstation_info = self.get_workstation_info() # returns list of device.get_info()

      diskstats = shutil.disk_usage('/')

      video_storage = DriveManager.get_video_storage_stats(DeviceRecorder.best_drive)
    #   DriveManager.print_drive_stats(video_storage)

      self.update_gui_callback({
          'type': 'Update',
          'workstation_info': workstation_info,
          'diskstats': diskstats, # I might be able to be removed, it's in video_storage
          'video_storage': video_storage,
          })

  def create_directory_structure(self,hdd,workstations,use_dev_dir=False):
        '''Creates timestamped directory to store vid files in
           Also updates the wslist such that each workstation in the list has it's
           corresponding w['dir'] value set to the absolute location where it will
           be stored.
           :return: Tuple(workstations,best_drive,session_dir_fullpath)
            workstations         : list of workstation dicts (id,ip,time,valid_ping)
            best_drive           : abs path to the best drive to record on (ex '/mnt/dd1','/mnt/dd2')
            session_dir_fullpath : abs path leading to session directory on best_drive
        '''

        drives = g.paths['hdd']
        sessions, min_session_id, max_session_id = get_all_sessions(drives)

        # if old sessions exist, then we want to record on the drive with the newest chapter files
        if sessions:
            newest_session_basename = sessions[-1].basename
            chosen_drive, _ = \
                DriveManager.find_drive_by_chapter(drives,newest_session_basename,'newest')
        else: # no sessions on drives --> pick first drive
            chosen_drive = drives[0]

        self.cur_drive = chosen_drive
        best_drive, max_session_id = DriveManager.pick_best_drive2(self.cur_drive,len(workstations))

        timestamp = f'{datetime.date.today().strftime("%Y-%b-%d")}_{time.strftime("%Hh%Mm%Ss", time.localtime())}'
        session_dir_fullpath = f'{best_drive}/{(max_session_id+1):02}_{timestamp}'
        fileutils.dcp_mkdir(session_dir_fullpath,g.log['group'],g.log['permissions'])
        for w in workstations:
            if (use_dev_dir):
                w['dir'] = session_dir_fullpath
            else:
                wid = f'{workstations.index(w) + 1:02}'
                w['dir'] = f'{session_dir_fullpath}/WS{wid}'
            if not os.path.isdir(w['dir']):
                fileutils.dcp_mkdir(w['dir'],g.log['group'],g.log['permissions'])

        return (workstations,best_drive,session_dir_fullpath)

  def __str__(self):
    s = "VidRecorder: "
    for (key, value) in self.__dict__.items():
        if (key == "name"):
            continue
        s += f"'{key}': '{value}',"
    s = s[0:-1]
    return s